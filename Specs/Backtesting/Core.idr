||| Backtesting Core Types - Position, Signal, Trade
|||
||| This module defines the foundational types for backtesting:
||| - Position: GADT for type-safe position states (NoPosition, Long, Short)
||| - Signal: Buy/Sell/Hold decisions
||| - Trade: Immutable trade records with entry/exit
||| - TradeResult: Returns both new position AND completed trade (if any)
|||
||| Design principles:
||| 1. Immutability: All types are immutable (no mutation bugs)
||| 2. Type safety: Invalid states are unrepresentable
||| 3. Pure functions: Deterministic signal generation
||| 4. Error handling: Either type for explicit failure modes
||| 5. Trade tracking: executeSignal returns completed trades for analysis

module Backtesting.Core

import Data.Vect

%default total

--------------------------------------------------------------------------------
-- Core Types
--------------------------------------------------------------------------------

||| Stock code (e.g., "005930" for Samsung)
public export
StockCode : Type
StockCode = String

||| Timestamp in milliseconds (Unix epoch)
public export
Timestamp : Type
Timestamp = Integer

||| Price in Korean Won (must be positive)
public export
record Price where
  constructor MkPrice
  value : Double
  {auto ok : value > 0.0 = True}

||| Quantity (number of shares, must be positive)
||| We use Nat but semantically it should be > 0
||| In Python, use Pydantic Field(gt=0)
public export
Quantity : Type
Quantity = Nat

||| Position state using GADT for type safety
|||
||| Invariants enforced at type level:
||| - NoPosition: No active position
||| - Long: Positive quantity at entry price and entry time
||| - Short: Positive quantity at entry price and entry time
|||
||| Note: We store stockCode and entryTime in Position so we can create Trade records on exit
public export
data Position : Type where
  ||| No active position
  NoPosition : Position

  ||| Long position (buy first, sell later)
  ||| @stockCode Stock being traded
  ||| @entryTime Timestamp when position was opened
  ||| @entryPrice Price at which shares were bought
  ||| @quantity Number of shares held (must be > 0, validated in Python)
  Long : (stockCode : StockCode) ->
         (entryTime : Timestamp) ->
         (entryPrice : Price) ->
         (quantity : Quantity) ->
         Position

  ||| Short position (sell first, buy back later)
  ||| @stockCode Stock being traded
  ||| @entryTime Timestamp when position was opened
  ||| @entryPrice Price at which shares were sold short
  ||| @quantity Number of shares shorted (must be > 0, validated in Python)
  Short : (stockCode : StockCode) ->
          (entryTime : Timestamp) ->
          (entryPrice : Price) ->
          (quantity : Quantity) ->
          Position

||| Position type predicates
public export
isLong : Position -> Bool
isLong (Long _ _ _ _) = True
isLong _ = False

public export
isShort : Position -> Bool
isShort (Short _ _ _ _) = True
isShort _ = False

public export
isFlat : Position -> Bool
isFlat NoPosition = True
isFlat _ = False

--------------------------------------------------------------------------------
-- Trading Signals
--------------------------------------------------------------------------------

||| Trading signal generated by strategy
public export
data Signal : Type where
  Buy  : Signal  -- Enter long position
  Sell : Signal  -- Enter short position or exit long
  Hold : Signal  -- Do nothing

||| Price point for signal generation (simplified candle)
public export
record PricePoint where
  constructor MkPricePoint
  timestamp : Timestamp
  price : Double

||| Signal generator must be deterministic (pure function)
||| Same input price points -> Same signal
public export
SignalGenerator : Type
SignalGenerator = List PricePoint -> Signal

--------------------------------------------------------------------------------
-- Trade Records
--------------------------------------------------------------------------------

||| Direction of trade
public export
data TradeDirection : Type where
  LongTrade  : TradeDirection
  ShortTrade : TradeDirection

||| Immutable trade record (represents a COMPLETED trade)
|||
||| Invariants (validated in Python with Pydantic):
||| - Entry must happen before exit (entryTime < exitTime)
||| - Prices must be positive
||| - Quantity must be positive
|||
||| This is only created when a position is CLOSED
public export
record Trade where
  constructor MkTrade
  stockCode    : StockCode
  direction    : TradeDirection
  entryTime    : Timestamp
  entryPrice   : Price
  exitTime     : Timestamp
  exitPrice    : Price
  quantity     : Quantity

||| Calculate PnL for a completed trade
|||
||| Long trade PnL:  (exitPrice - entryPrice) × quantity
||| Short trade PnL: (entryPrice - exitPrice) × quantity
public export
tradePnL : Trade -> Double
tradePnL trade =
  let entryVal = trade.entryPrice.value
      exitVal  = trade.exitPrice.value
      qty      = cast trade.quantity
  in case trade.direction of
       LongTrade  => (exitVal - entryVal) * qty
       ShortTrade => (entryVal - exitVal) * qty

||| Calculate return percentage for a trade
|||
||| Return% = (PnL / (entryPrice × quantity)) × 100
public export
tradeReturn : Trade -> Double
tradeReturn trade =
  let pnl = tradePnL trade
      entryVal = trade.entryPrice.value
      qty = cast trade.quantity
      capital = entryVal * qty
  in (pnl / capital) * 100.0

--------------------------------------------------------------------------------
-- Trade Execution
--------------------------------------------------------------------------------

||| Errors that can occur during trade execution
public export
data TradeError : Type where
  ||| Trying to buy when already long
  AlreadyLong : TradeError

  ||| Trying to sell short when already short
  AlreadyShort : TradeError

  ||| Trying to exit when no position exists
  NoPositionToExit : TradeError

  ||| Insufficient capital to open position
  InsufficientCapital : (required : Double) -> (available : Double) -> TradeError

  ||| Invalid price (negative or zero)
  InvalidPrice : (price : Double) -> TradeError

  ||| Invalid quantity (zero)
  InvalidQuantity : TradeError

  ||| Time travel (exit before entry)
  InvalidTime : (entryTime : Timestamp) -> (exitTime : Timestamp) -> TradeError

||| Show instance for TradeError
public export
Show TradeError where
  show AlreadyLong = "Already in long position"
  show AlreadyShort = "Already in short position"
  show NoPositionToExit = "No position to exit"
  show (InsufficientCapital req avail) =
    "Insufficient capital: required " ++ show req ++ ", available " ++ show avail
  show (InvalidPrice p) = "Invalid price: " ++ show p
  show InvalidQuantity = "Invalid quantity: must be > 0"
  show (InvalidTime entry exit) =
    "Invalid time: exit (" ++ show exit ++ ") must be > entry (" ++ show entry ++ ")"

||| Result of trade execution
|||
||| Returns:
||| - New position state
||| - Maybe Trade: Just trade if position was closed, Nothing if opened/held
public export
TradeResult : Type
TradeResult = Either TradeError (Position, Maybe Trade)

||| Execute a signal to transition position state
|||
||| CRITICAL CHANGE: Now returns (Position, Maybe Trade)
||| - Position: New position state after signal
||| - Maybe Trade: Just trade if a position was CLOSED, Nothing otherwise
|||
||| State machine:
||| NoPosition + Buy  -> (Long, Nothing)         -- Open long
||| NoPosition + Sell -> (Short, Nothing)        -- Open short
||| Long       + Sell -> (NoPosition, Just trade) -- Close long
||| Short      + Buy  -> (NoPosition, Just trade) -- Close short
||| *          + Hold -> (unchanged, Nothing)     -- No change
|||
||| Invalid transitions return Left TradeError
|||
||| @signal The trading signal to execute
||| @position Current position state
||| @stockCode Stock code for new positions
||| @currentTime Current timestamp (for exit time)
||| @currentPrice Current market price
||| @quantity Number of shares to trade
public export
executeSignal : Signal ->
                Position ->
                (stockCode : StockCode) ->
                (currentTime : Timestamp) ->
                (currentPrice : Price) ->
                (quantity : Quantity) ->
                TradeResult

-- Open new long position
executeSignal Buy NoPosition stockCode currentTime currentPrice quantity =
  Right (Long stockCode currentTime currentPrice quantity, Nothing)

-- Open new short position
executeSignal Sell NoPosition stockCode currentTime currentPrice quantity =
  Right (Short stockCode currentTime currentPrice quantity, Nothing)

-- Close long position (create Trade record)
executeSignal Sell (Long posStockCode entryTime entryPrice qty) _ currentTime currentPrice _ =
  if currentTime > entryTime
    then let trade = MkTrade posStockCode LongTrade entryTime entryPrice currentTime currentPrice qty
         in Right (NoPosition, Just trade)
    else Left (InvalidTime entryTime currentTime)

-- Close short position (create Trade record)
executeSignal Buy (Short posStockCode entryTime entryPrice qty) _ currentTime currentPrice _ =
  if currentTime > entryTime
    then let trade = MkTrade posStockCode ShortTrade entryTime entryPrice currentTime currentPrice qty
         in Right (NoPosition, Just trade)
    else Left (InvalidTime entryTime currentTime)

-- Invalid: Cannot go long when already long
executeSignal Buy (Long _ _ _ _) _ _ _ _ =
  Left AlreadyLong

-- Invalid: Cannot go short when already short
executeSignal Sell (Short _ _ _ _) _ _ _ _ =
  Left AlreadyShort

-- Hold: No change, no trade
executeSignal Hold pos _ _ _ _ =
  Right (pos, Nothing)

--------------------------------------------------------------------------------
-- Position Information
--------------------------------------------------------------------------------

||| Get current position value at market price
public export
positionValue : Position -> Price -> Double
positionValue NoPosition _ = 0.0
positionValue (Long _ _ _ qty) marketPrice =
  cast qty * marketPrice.value
positionValue (Short _ _ _ qty) marketPrice =
  cast qty * marketPrice.value

||| Get unrealized PnL for open position
public export
unrealizedPnL : Position -> Price -> Double
unrealizedPnL NoPosition _ = 0.0
unrealizedPnL (Long _ _ entryPrice qty) marketPrice =
  let entryVal = entryPrice.value
      marketVal = marketPrice.value
      qtyDouble = cast qty
  in (marketVal - entryVal) * qtyDouble
unrealizedPnL (Short _ _ entryPrice qty) marketPrice =
  let entryVal = entryPrice.value
      marketVal = marketPrice.value
      qtyDouble = cast qty
  in (entryVal - marketVal) * qtyDouble

--------------------------------------------------------------------------------
-- Property Tests (Specifications)
--------------------------------------------------------------------------------

{-
These properties specify the expected behavior but require full proofs.
In production code, these would be tested via unit tests in Python/TypeScript.

||| Property 1: PnL of long trade with same entry/exit price is zero
For a long trade where entryPrice == exitPrice:
  tradePnL = (exitPrice - entryPrice) × quantity = 0

||| Property 2: Short trade PnL is inverse of long trade PnL
For same price movement:
  shortPnL = (entryPrice - exitPrice) × qty
  longPnL  = (exitPrice - entryPrice) × qty
  Therefore: shortPnL = -longPnL

||| Property 3: Hold signal preserves position
executeSignal Hold pos _ _ _ _ = Right (pos, Nothing)

||| Property 4: Cannot double long/short
executeSignal Buy  (Long  ...) _ _ _ _ = Left AlreadyLong
executeSignal Sell (Short ...) _ _ _ _ = Left AlreadyShort

||| Property 5: Opening position creates no trade
executeSignal Buy  NoPosition ... = Right (Long  ..., Nothing)
executeSignal Sell NoPosition ... = Right (Short ..., Nothing)

||| Property 6: Closing position creates trade record
executeSignal Sell (Long  ...) ... = Right (NoPosition, Just trade)
executeSignal Buy  (Short ...) ... = Right (NoPosition, Just trade)
-}

--------------------------------------------------------------------------------
-- Python Implementation Guide
--------------------------------------------------------------------------------

{-
Python implementation notes:

1. Position (use Pydantic with discriminated union):

```python
from typing import Literal
from pydantic import BaseModel, Field

class NoPosition(BaseModel):
    type: Literal["no_position"] = "no_position"

class LongPosition(BaseModel):
    type: Literal["long"] = "long"
    stock_code: str
    entry_time: int  # milliseconds
    entry_price: float = Field(gt=0)
    quantity: int = Field(gt=0)

class ShortPosition(BaseModel):
    type: Literal["short"] = "short"
    stock_code: str
    entry_time: int
    entry_price: float = Field(gt=0)
    quantity: int = Field(gt=0)

Position = NoPosition | LongPosition | ShortPosition
```

2. Signal (use Enum):

```python
from enum import Enum

class Signal(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
```

3. Trade (use Pydantic with validators):

```python
class Trade(BaseModel):
    stock_code: str
    direction: Literal["long", "short"]
    entry_time: int  # milliseconds
    entry_price: float = Field(gt=0)
    exit_time: int
    exit_price: float = Field(gt=0)
    quantity: int = Field(gt=0)

    @model_validator(mode='after')
    def validate_time_order(self):
        if self.entry_time >= self.exit_time:
            raise ValueError("entry_time must be < exit_time")
        return self

    def pnl(self) -> float:
        """Calculate PnL for this trade"""
        if self.direction == "long":
            return (self.exit_price - self.entry_price) * self.quantity
        else:  # short
            return (self.entry_price - self.exit_price) * self.quantity

    def return_pct(self) -> float:
        """Calculate return percentage"""
        capital = self.entry_price * self.quantity
        return (self.pnl() / capital) * 100.0
```

4. executeSignal (CRITICAL: Returns tuple (Position, Optional[Trade])):

```python
from typing import Optional
from returns.result import Result, Success, Failure

def execute_signal(
    signal: Signal,
    position: Position,
    stock_code: str,
    current_time: int,
    current_price: float,
    quantity: int
) -> Result[tuple[Position, Optional[Trade]], TradeError]:
    """
    Execute a signal and return new position + maybe completed trade

    Returns:
        Success((new_position, maybe_trade)) or Failure(error)
    """
    match (signal, position):
        case (Signal.BUY, NoPosition()):
            # Open long position, no trade created
            new_pos = LongPosition(
                stock_code=stock_code,
                entry_time=current_time,
                entry_price=current_price,
                quantity=quantity
            )
            return Success((new_pos, None))

        case (Signal.SELL, NoPosition()):
            # Open short position, no trade created
            new_pos = ShortPosition(
                stock_code=stock_code,
                entry_time=current_time,
                entry_price=current_price,
                quantity=quantity
            )
            return Success((new_pos, None))

        case (Signal.SELL, LongPosition() as pos):
            # Close long position, create trade record
            if current_time <= pos.entry_time:
                return Failure(TradeError.INVALID_TIME)

            trade = Trade(
                stock_code=pos.stock_code,
                direction="long",
                entry_time=pos.entry_time,
                entry_price=pos.entry_price,
                exit_time=current_time,
                exit_price=current_price,
                quantity=pos.quantity
            )
            return Success((NoPosition(), trade))

        case (Signal.BUY, ShortPosition() as pos):
            # Close short position, create trade record
            if current_time <= pos.entry_time:
                return Failure(TradeError.INVALID_TIME)

            trade = Trade(
                stock_code=pos.stock_code,
                direction="short",
                entry_time=pos.entry_time,
                entry_price=pos.entry_price,
                exit_time=current_time,
                exit_price=current_price,
                quantity=pos.quantity
            )
            return Success((NoPosition(), trade))

        case (Signal.BUY, LongPosition()):
            return Failure(TradeError.ALREADY_LONG)

        case (Signal.SELL, ShortPosition()):
            return Failure(TradeError.ALREADY_SHORT)

        case (Signal.HOLD, _):
            # No change, no trade
            return Success((position, None))
```

5. Example usage (collecting trades):

```python
# Backtesting loop
position = NoPosition()
trades: list[Trade] = []

for candle in candles:
    # Generate signal from strategy
    signal = strategy.generate_signal(candle)

    # Execute signal
    result = execute_signal(
        signal,
        position,
        stock_code=candle.stock_code,
        current_time=candle.timestamp,
        current_price=candle.close_price,
        quantity=100
    )

    match result:
        case Success((new_position, maybe_trade)):
            position = new_position
            if maybe_trade is not None:
                trades.append(maybe_trade)  # Collect completed trade
                print(f"Trade closed: PnL={maybe_trade.pnl():.2f}")

        case Failure(error):
            print(f"Trade error: {error}")

# Analyze performance
total_pnl = sum(t.pnl() for t in trades)
avg_return = sum(t.return_pct() for t in trades) / len(trades) if trades else 0
win_rate = sum(1 for t in trades if t.pnl() > 0) / len(trades) if trades else 0

print(f"Total PnL: {total_pnl:,.0f} KRW")
print(f"Average return: {avg_return:.2f}%")
print(f"Win rate: {win_rate:.1%}")
```
-}

